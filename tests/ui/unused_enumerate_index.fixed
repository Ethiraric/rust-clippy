#![allow(unused, clippy::map_identity)]
#![warn(clippy::unused_enumerate_index)]

use std::iter::Enumerate;

fn get_enumerate() -> Enumerate<std::vec::IntoIter<i32>> {
    vec![1].into_iter().enumerate()
}

fn main() {
    let v = [1, 2, 3];
    for x in v.iter() {
        println!("{x}");
    }

    struct Dummy1;
    impl Dummy1 {
        fn enumerate(self) -> Vec<usize> {
            vec![]
        }
    }
    let dummy = Dummy1;
    for x in dummy.enumerate() {
        println!("{x}");
    }

    struct Dummy2;
    impl Dummy2 {
        fn enumerate(self) -> Enumerate<std::vec::IntoIter<usize>> {
            vec![1, 2].into_iter().enumerate()
        }
    }
    let dummy = Dummy2;
    for (_, x) in dummy.enumerate() {
        println!("{x}");
    }

    let mut with_used_iterator = [1, 2, 3].into_iter().enumerate();
    with_used_iterator.next();
    for (_, x) in with_used_iterator {
        println!("{x}");
    }

    struct Dummy3(std::vec::IntoIter<usize>);

    impl Iterator for Dummy3 {
        type Item = usize;

        fn next(&mut self) -> Option<Self::Item> {
            self.0.next()
        }

        fn size_hint(&self) -> (usize, Option<usize>) {
            self.0.size_hint()
        }
    }

    let dummy = Dummy3(vec![1, 2, 3].into_iter());
    for x in dummy {
        println!("{x}");
    }

    let _ = vec![1, 2, 3].into_iter().map(|x| println!("{x}"));

    let p = vec![1, 2, 3].into_iter();
    p.map(|x| println!("{x}"));

    // This shouldn't trigger the lint. `get_enumerate` may come from an external library on which we
    // have no control.
    let p = get_enumerate();
    p.map(|(_, x)| println!("{x}"));

    // This shouldn't trigger the lint. The `enumerate` call is in a different context.
    macro_rules! mac {
        () => {
            [1].iter().enumerate()
        };
    }
    _ = mac!().map(|(_, v)| v);

    macro_rules! mac2 {
        () => {
            [1].iter()
        };
    }
    _ = mac2!().map(|_v| {});

    [1].iter().map(|x| x);
    [1].iter().map(|x| {
        if *x == 0 {
            x + 3
        } else {
            println!("{}", x);
            *x
        }
    });

    // This shouldn't trigger the lint. `x` might be used later to access the index.
    [1].iter().enumerate().map(|x| x);
    // This shouldn't trigger the lint. `x` is used.
    [1].iter().enumerate().map(|x| println!("{x:?}"));
    // This shouldn't trigger the lint. `x.0` is used.
    [1].iter().enumerate().map(|x| {
        if x.0 == 0 {
            x.1 + 3
        } else {
            println!("{}", x.1);
            *x.1
        }
    });
}
